# aed-18
Lab exercises of the Packet Switching and Processing Architectures course of the Computer Science and Networking Master's Degree @ University of Pisa

| <b>Lab number</b> | <b>Language/Framework/Tool</b> | <b>Description</b> |
| ---------- | ----------------------- | ----------- |
| 1 | C++, libpcap | A simple program that takes an interface as input parameter. It first checks if the interface is in the list of devices returned by `pcap_findalldevs()`: if yes it calls the `pcap_open_live()` on that interface, otherwise a valid interface is requested. Once the descriptor has been correctly opened a packet will be captured with the `pcap_next()` and some information on its content will be printed out. |
| 2 | C++, libpcap | A simple program that takes a pcap file as input parameter. A descriptor is obtained with the `pcap_open_offline()`. The `pcap_next()` is used and some information on the content of the captured packet will be printed out. VLAN traffic ([IEEE 802.1Q](https://en.wikipedia.org/wiki/IEEE_802.1Q)) has been managed. |
| 3 | C++, libpcap | A simple program that takes as input parameters a pcap file and the number of packets to be captured. A descriptor is obtained with the `pcap_open_offline()`. The `pcap_loop()` is used and a packet handler callback is defined. The callback is supposed to be called on a per-packet basis and implements the parsers of the protocol headers. |
| 4 | C++, libpcap | A program that obtains packets from a pcap file and does some analysis. It requires as input parameters a pcap file and the number of packets to be captured. The computation returns the number (and the list) of the different source IP addresses found in the analyzed traffic. |
| 5 | C++, libpcap | A program that uses the pcap library to capture some traffic and identifies and analyzes different flows. The capture can be done both with the `pcap_one_live()` in case the user specifies a network interface as input parameter, or with the `pcap_open_offline()` in case the user specifies a pcap capture file as input. Moreover, the user can always specify the number of packets that he wants to analyze. The aim of the program is to identify different flows (where a flow is a tuple IP source address, IP destination address, source port, destination port and protocol) and to count how many packets belong to a certain flow. <br>Two different implementations are provided: <ul><li>1. an unordered map where the keys are the flow tuples and the values are the packet counters for each flow; only C++ base mechanism and library are used in this case.</li><li>2. a bloom filter and a counting bloom filter randomized data structures used to check set membership for the flows and to count the packets per flow; the [MurmurHash3](https://github.com/aappleby/smhasher) function has been used in order to produce 128-bit hash values efficiently.</li></ul> Finally the program outputs a table containing the results produced by both approaches: the idea was to show consistency between the results produced by the two methods. |